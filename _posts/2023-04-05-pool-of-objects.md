---
layout: post
title: "Пул объектов Android Util"
tags: [kotlin, pool]
comments: false
---

Пул объектов позволяет избегать лишнего создания объектов, которые бывает избыточно создавать и уничтожать. В определённых случаях его использование позволяет повысить производительность приложения.
Новый объект будет создаваться только в том случае, если он не был найден в пуле. После того, как объект уже не нужен, он возвращается в пул и может быть извлечён для повторного использования.
В библиотеке *androidx.core.util* есть интерфейс **Pool**, а так же две готовые реализации **SimplePool** и **SynchronizedPool**.

[Pools](https://developer.android.com/reference/androidx/core/util/Pools)

Основной интерфейс содержит два метода:
   * acquire - для получения объекта
   * release - для отправки обратно в пул

**SimplePool** - простая реализация **Pool**, пул фиксированного размера.
Метод *acquire* достаёт из пула объект, помещённый последним и возвращает его, если такого нет, то возвращается null.
Метод *release* помещает объект в начало пула. Причём если данный объект уже в пуле, то будет исключение, а если мы пытаемся добавить объект, когда размер пула уже максимальный, то добавление проигнорируется. Об успешности добавления можно узнать прочитав результат выполнения метода.
**SynchronizedPool** - расширение **SimplePool**, где методы *acquire* и *release* обёрнуты в synchronized для синхронизации доступа.

Небольшой пример использования **SimplePool**:

``` kotlin
private val pool = Pools.SimplePool<PoolObject>(5)

private fun poolManipulation() {
    val obj = pool.acquire() ?: PoolObject("some object")
    // do manipulations with obj
    pool.release(obj)
}

class PoolObject(val data: String)
```

Можно заметить, что изначально объекта в пуле не было и его создали "вручную", а после использования поместили в пул с помощью *release* и при следующем вызове *acquire* нам вернётся ранее созданный объект, после чего место в пуле будет освобождено.
