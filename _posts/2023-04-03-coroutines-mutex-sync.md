---
layout: post
title: "Синхронизация корутин с помощью Mutex"
tags: [kotlin, coroutines, mutex]
comments: false
---

Типовые сценарии обычного клиент-серверного приложения Android подразумевают единичные запросы к серверу с последующей их обработкой - обычно так выглядит сценарий использования корутин. Тем не менее бывают ситуации, когда необходимо обеспечить доступ к изменяемому объекту, либо нужно "поставить на паузу" часть асинхронных запросов. 

Помимо обычных сценариев, где нужно считать и записать, например, инкремент переменной, могу быть и сценарии с обновлением пользовательского токена, когда несколько запросов могут попросить обновить его, но запрос на обновление может быть только один и пока его обновляют, запросы ждут и после успешного обновления можно продолжить предыдущие запросы, но уже с обновлённым токеном. В мире java thread на помощь приходит synchronized. В мире корутин может помочь Mutex.

``` kotlin
val mutex = Mutex()

scope.launch {
    mutex.lock()
    // do work
    mutex.unlock()
}
```

Принцип примерно такой: Корутина начинает выполняться -> захватывает mutex: lock() -> делает работу -> отпускает mutex: unlock(). Т.к. у mutex может быть только один владелец, то когда приходит новая корутина - она будет ждать до тех пор, пока у mutex не вызовут unlock() и только после этого может приступит к работе. Поскольку lock() - это suspend функция, то полной блокировки потока не будет.

Есть расширение withLock, которое делает работу с mutex простой:

``` kotlin
public suspend inline fun <T> Mutex.withLock(owner: Any? = null, action: () -> T): T {
    contract { 
        callsInPlace(action, InvocationKind.EXACTLY_ONCE)
    }

    lock(owner)
    try {
        return action()
    } finally {
        unlock(owner)
    }
}
```

Вызов с расширением:

``` kotlin
val mutex = Mutex()

scope.launch {
    mutex.withLock { 
        // do work
    }
}
```

Как можно заметить, выглядит достаточно просто и если необходимо будет обращаться к одному ресурсу из нескольких потоков, то в котлин хорошо подходит механизм Mutex. Так же стоит помнить, что механизмы синхронизации Java не очень подходят для корутин в Kotlin, поскольку могут заблокировать поток, в котором вызывается корутина.